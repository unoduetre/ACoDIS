\documentclass{classrep}
\usepackage{polski}
\input{packages-article}

\studycycle{Informatyka, studia dzienne}
\coursesemester{III}

\coursename{Pracownia Problemowa}
\courseyear{2014}

\courseteacher{dr. inż Aneta Poniszewska-Marańda}
\coursegroup{poniedziałek, 14:15}

\author{
  \studentinfo{Mateusz Grotek}{186816} \and
  \studentinfo{Mateusz Jakóbczak}{186819} \and
  \studentinfo{Rafał Jurkiewicz}{186822} \and
  \studentinfo{Łukasz Kotyński}{186829} \and
  \studentinfo{Paweł Tarasiuk}{186875}
}

\title{Kontrola dostępu w dynamicznych systemach informatycznych}


\begin{document}
\maketitle

\section{Problem}
Przedstawiony problem dotyczy tworzenia i analizy zaawansowanych, inteligentnych mechanizmów kontroli dostępu w dynamicznych systemach informatycznych. Celem projektu jest
zapoznanie się ze stosowanymi rozwiązaniami, zdobycie aktualnej wiedzy na ten temat, a także wykonanie praktycznej implementacji wybranych rozwiązań.
\section{Wprowadzenie}
Pierwszą rzeczą, jaką należy zrobić w celu rozwiązania postawionego werbalnie problemu jest dokładne zrozumienie określeń użytych w jego specyfikacji. W wypadku
kontroli dostępu w dynamicznych systemach informatycznych istotną rzeczą jest zwrócenie uwagi na pojęcia kontroli dostępu i dynamicznego systemu informatycznego. Jako, że główna
część zagadnienia skupia się na zapewnieniu kontroli dostępu, wyjaśnimy najpierw drugie, mniej istotne pojęcie, jakim są dynamiczne systemy informatyczne.

Pojęcie dynamiki można tutaj
rozumieć na różne sposoby, ale na pewno podstawowym aspektem jest tutaj wrażliwość na zmieniające się warunki, takie jak na przykład czas, lub pewne zdarzenia zachodzące zarówno 
w samym systemie, jak i poza nim. Oznacza to, że system nie powiniem robić żadnych założeń na temat tego co się aktualnie dzieje, a raczej reagować dynamicznie. Dla porównania
możemy wskazać na przykład dostęp do plików na serwerze. Rozwiązanie statyczne mogłoby polegać na przykład na tym, że w systemie jest na stałe zapamiętane (zaszyfrowane) hasło,
które użytkownik musi podać przy logowaniu, po którym uzyskuje pełny i nieograniczony czasowo dostęp do pewnych, na sztywno zdefiniowanych zasobów, takich jak pewne pliki w pewnych katalogach.
Skontrastujmy to z systemem w którym dostęp do plików jest ograniczony pod względem na przykład ilości osób, które jednocześnie z nich korzystają, przy czym czas korzystania może być ograniczony
w zależności od konkretnej osoby, a także od ilości osób. Poza tym dostęp może być włączany konkretnym osobom w konkretnych godzinach. Co więcej, uzyskanie dostępu może zależeć od
wydania zezwolenia. Jak widać stworzenie systemu dynamicznego jest dużo trudniejsze od stworzenia systemu statycznego.

Wróćmy teraz do pojęcia kontroli dostępu. Kontrola dostępu oznacza, że dostęp do pewnych zasobów jest, z jednej strony, dozwolony lub zabroniony, natomiast z drugiej, że
jest on nadzorowany, czyli że na przykład każde skorzystanie z zasobów jest zapisywane, lub nawet zatwierdzane przez odpowiednią osobę. Wynika z tego, że elementami kontroli
dostępu są nie tylko autentykacja i autoryzacja, ale także wydawanie zgody na dostęp i audyt.
\section{Aktualny stan wiedzy}
Jest wiele różnych sposobów na zapewnienie kontroli dostępu. Co więcej sposoby te niekoniecznie kolidują ze sobą, a często mogą ze sobą współpracować. Do podstawowych mechanizmów
mogących zapewnić kontrolę dostępu należą\cite{owasp}\cite{computer}\cite{wikibooks}:
\begin{itemize}
\item kontrola dostępu uznaniowa \textit{Discretionary Access Control, DAC}
\item kontrola dostępu obowiązkowa \textit{Mandatory Access Control, MAC}
\item kontrola dostępu oparta na rolach \textit{Role Based Access Control, RBAC}.
\end{itemize}
Każdy z tych modeli różni się elementem, który przydziela prawa dostępu, a także mechanizmami dostępu\cite{wikibooks}. 

W przypadku \textbf{DAC} zarządzaniem uprawnieniami zajmują się właściciele danych. Często wykorzystywane są do tego listy kontroli dostępu (\textit{Access Control Lists, ACLs}).
Dobrym przykładem takiego rozwiązania jest dostęp do plików i katalogów na dysku w Uniksie/Linuksie. Właściciel pliku/katalogu może ustawić prawa dostępu dla siebie, grupy, do której należy
dany plik, a także dla osób spoza grupy. Prawa te, to prawa odczytu, zapisu i wykonywania, a także pewne dodatkowe prawa o których nie będziemy tutaj pisać. Jednoczesną zaletą i wadą takiego
rozwiązania jest fakt, że zarządzanie uprawnieniami dokonywane jest przez właścicieli zasobów. Jest to zaleta, gdyż łatwo jest zarządzać właścicielowi zasobami, które tylko on posiada,
gdyż ich ilość jest ograniczona. Jest to wada, gdyż brak jest centralnego nadzoru nad uprawnieniami.

Przypadek \textbf{MAC} zakłada, że przydzielaniem uprawnień zajmuje się sam system na podstawie etykiet przydzielonych do osób i zasobów. Na przykład jeśli osoba ma przydzieloną
etykietę ,,Secret'', to może ona przeglądać zasoby oznaczone jako ,,Secret'', a także zasoby na poziomach niższych. Nie może już za to przeglądać zasobów oznaczonych jako ,,Top Secret''.
Sam system zapewnia dostęp do zasobów na podstawie ustalonej w trakcie jego tworzenia polityki bezpieczeństwa.

Przypadek \textbf{RBAC} bazuje na przydzieleniu dla każdego użytkownika jego roli w organizacji. Przydzielaniem ról i uprawnień do ról zajmuje się administrator. Następnie każdej roli
są przydzielane dostępne dla niej zasoby.

Amerykańskie ministerstwo obrony (DoD) zdefiniowało w dokumencie Trusted Computer System Evaluation Criteria\cite{tcsec} (w skrócie TCSEC) następujące 4 poziomy dostępu:
\begin{itemize}
\item A -- ochrona zweryfikowana
\item B -- ochrona obowiązkowa
\item C -- ochrona uznaniowa
\item D -- ochrona minimalna
\end{itemize}

Ochrona minimalna dotyczy systemów, które zostały ocenione, ale nie spełniły żadnych kryteriów. Kolejne poziomy oznaczają lepszą ochronę. W wypadku poziomu C możliwa jest
tylko ochrona DAC. Dla poziomu B mamy także politykę ochrony, czyli dodatkowo MAC. W wypadku A procedury zostały formalnie zweryfikowane (np. przez podanie dowodu poprawności programu).

W naszym projekcie postanowiliśmy użyć połączenia modeli RBAC i MAC. Z modelu RBAC weźmiemy pojęcie roli. Każdy użytkownik będzie przypisany do określonej roli, której przysługują
określone uprawnienia. Jednakże nie będą to uprawnienia statyczne, ale dynamiczne, co oznacza, że w pewnych warunkach pewne uprawnienia będą nieważne lub ograniczone.
W tym celu zastosowane zostaną elementy modelu MAC. Inaczej mówiąc model RBAC będzie miał za zadanie zapewnić pewne statyczne uprawnienia, które następnie będą modyfikowane dynamiczne
przez odpowiednie zdarzenia zachodzące w systemie i poza nim. Oznacza to, że nasz system uprawnień będzie miał strukturę dwuwarstwową. Pierwszą warstwę będą stanowić
przypisane przez administratora systemu role i ich uprawnienia. Nazwijmy takie uprawnienia \textbf{możliwościami} roli. To że rola ma możliwość nie oznacza automatycznie,
że ma ona także \textbf{uprawnienie}. Zdecyduje o tym system na podstawie aktualnych zdarzeń.

Model RBAC został wstępnie opisany w artykule Ferraiolo i Kuhna\cite{RBAC}, a dalsze szegóły można znaleźć w artykule Sandhu, Ferraiolo i Kuhna\cite{NistModel}.
Amerykański Narodowy Instytut Standardów i Technologii (National Institute of Standards and Technology) opracował model\cite{NIST}, którego celem jest standaryzacja systemów
bazujących na rolach. Role stanowią element pośredni, ułatwiający zarządzanie. Do jednej roli może być przyporządkowana więcej niż jedna osoba. Ponadto do jednej roli mogą być
przyporządkowane różne zasoby.

Standard NIST podzielił systemy RBAC na 4 klasy, przy czym każda następna klasa jest rozszerzeniem poprzedniej:
\begin{itemize}
\item płaski RBAC
\item hierarchiczny RBAC
\item RBAC z więzami
\item symetryczny RBAC
\end{itemize}
Najprostszą odmianą jest płaski RBAC, który zawiera powiązania między rolami a użytkownikami i uprawnieniami. RBAC hierarchiczny dodatkowo zawiera powiązania między rolami,
takie jak na przykład dziedziczenie. W RBAC z więzami dodatkowo jest zapewniona spójność ról i podział odpowiedzialności, a także ograniczenia na powiązania między użytkownikami
i rolami, a także pomiędzy jedną rolą a drugą. W symetrycznym RBAC dodatkowo jest możliwość nakładania ograniczeń na powiązania między rolami a uprawnieniami. Jest także możliwość przeglądania
i zaawansowanego zarządzania uprawnieniami.

Nasz system chcemy zrealizować jako system z uprawnieniami bazującymi na regułach. Silniki reguł biznesowych to popularne rozwiązanie w firmach. Służą tam one na przykład to zarządzania
przepływem dokumentów, a także zarządzania zasobami ludzkimi. Najpopularniejszym rozwiązaniem jest Drools\cite{Drools}, który jest systemem reguł przeznaczonym dla środowiska Java i rozwijanym
przez firmę RedHat. Jednakże w naszym projekcie chcemy użyć innego sprawdzonego rozwiązania, jakim jest język Prolog\cite{Prolog}. Jest to język programowania deklaratywnego w logice,
który jest bardzo dobrze dostosowany do rozwiązywania skomplikowanych problemów w których występuje wiele reguł. 
\section{Opis rozwiązania problemu}
Posta

W tej sekcji należy przedstawić zaproponowane rozwiązanie postawionego problemu:
\begin{itemize}
\item koncepcje, metody, podejścia użyte do stworzenia rozwiązania,
\item własną koncepcję rozwiązania (popartą podlądowymi rysunkami),
\item architekturę rozwiązania,
\item zależności poszczególnych komponentów rozwiązania,
\item przykładowy proces działania zaproponowanego rozwiązania w ramach opisu teoretyczno-praktycznego,
\item krótki opis ewaluacji stworzonego rozwiązania, czyli przykładowo, aby udowodnić poprawność zrealizowanego rozwiązania problemu, stworzono przykładowy system lub przykładową aplikację o takiej a takiej funkcjonalności,
\item ...
\end{itemize}

Przedstwiony opis rozwiązania powinien być poparty licznymi rysunkami.


\section{Opis implementacji}

Należy tu zamieścić krótki opis zaprojektowanych elementów (komponentów) składających się na implementację zaproponowanego rozwiązania. Do tego celu można wykorzystać diagramy UML. Należy także podać technologie, które użyto do budowy systemu lub aplikacji.

Następnie należy przestawić opis zrealizowanego systemu lub aplikacji w postaci dokumentacji użytkownika.


\section{Dyskusja rozwiązania i podsumowanie}

Sekcja ta powinna zawierąć dyskusję stworzonego rozwiązania w odniesieniu do istniejących koncepcji, podejść, metod oraz technik i technologii. Każdy wniosek powinien mieć poparcie we wcześniej przeprowadzonych badaniach (zarówno teoretycznych, jak i praktycznych).

Należy również omówić i wyjaśnić wszystkie napotkane problemy, jeżeli takie były.

Następnie należy podsumować powyższe wnioski oraz zaproponować ewentualne kierunki rozwoju stworzonego rozwiązania.

\section{Udział w projekcie}

Proszę przedstwić udział poszczególnych osób w realizacji projektu: 
\begin{itemize}
\item podział prac,
\item zadania, czynności zrealizwoane przez każdą osobę.
\end{itemize}


\begin{thebibliography}{10}
\bibitem{owasp}Access Control Cheat Sheet \url{https://www.owasp.org/index.php/Access\_Control\_Cheat\_Sheet}
\bibitem{computer}Computer access control \url{http://en.wikipedia.org/wiki/Computer\_access\_control}
\bibitem{wikibooks}Access Control Systems w \textsl{Fundamentals of Information Systems Security} \url{http://en.wikibooks.org/wiki/Fundamentals\_of\_Information\_Systems\_Security/Access\_Control\_Systems#Access\_Control\_Models}
\bibitem{TCSEC}Trusted Computer System Evaluation Criteria \url{http://en.wikipedia.org/wiki/Trusted\_Computer\_System\_Evaluation\_Criteria}
\bibitem{NIST}Role Based Access Control (RBAC) and Role Based Security \url{http://csrc.nist.gov/groups/SNS/rbac/}
\bibitem{RBAC}Ferraiolo, D. F., Kuhn, D.R., 1992. Role-Based Access Control. 15th National Computer Security Conference
\bibitem{NISTModel}Sandhu, R., Ferraiolo D., Kuhn R. 2000. The NIST Model for  Role Based Access Control:  Toward a Unified Standard. 
Proceedings, 5th ACM Workshop on Role Based Access Control, Lipiec 26--27, 2000, Berlin, pp. 47--63 
\bibitem{Drools}Drools -- The Business Logic integration Platform \url{https://www.jboss.org/drools/}
\bibitem{Prolog}Kluźniak F., Szpakowicz S. 1985. Prolog For Programmers.
\end{thebibliography}
\end{document}
